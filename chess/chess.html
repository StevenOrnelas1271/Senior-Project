<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="UTF-8">
		<title>PIXI Chess Game</title>
		<style>
			body {
				margin: auto;
				padding: 0;
				position: absolute;
				background-color: #000000;
			}
		</style>
		<script src="pixi.js"></script>
	</head>
	<body>
		<script>
		var stage = new PIXI.Stage(0xaaaaaca);
		var renderer = PIXI.autoDetectRenderer(600, 500);
		document.body.appendChild(renderer.view);
		
		// load images from an image path
		var textureButton = PIXI.Texture.fromImage("assets/white_grid.png");
		var textureButtonDown = PIXI.Texture.fromImage("assets/king-test.png");
		var eButtonOver = PIXI.Texture.fromImage("assets/pawn-test.png");
		
		// global variables
		var currentPiece = 0;
		var pieceSelected = false;
		var pieceType;
		var status;
		var playerNum;
		var defaultColor = 0xffffff;
		var currentPosition;
		var gridNum;
		var pieceMoved;
		var white = 0, black = 1;
		var playerTurn = white;
		var pieceColor;
		var numPieces = 20;
		var type;
		var captured;
		var rowNum;
		var colNum;

		var wp1 = 1, wp2 = 2, wp3 = 3, wp4 = 4, wp5 = 5, wp6 = 6, wp7 = 7, wp8 = 8;
		var bp1 = 9, bp2 = 10, bp3 = 11, bp4 = 12, bp5 = 13, bp6 = 14, bp7 = 15, bp8 = 16;
		var wr1 = 17, wr2 = 18;
		var br1 = 19, br2 = 20;
		
		var firstMove;
		
		//setup chessboard
		var container = new PIXI.Stage();	
		stage.addChild(container);
		//generate grid image and position
		var gridsize = 36;
		/*
		for (var j = 0; j < 12; j++){
			for (var i = 0; i < 10; i++){
				if ((i >= 1 && i <= 8) && (j >= 2 && j <= 9)){
					if ((i%2 == 0 && j%2 != 0) || i%2 != 0 && j%2 ==0){
						var grid = PIXI.Sprite.fromImage("assets/black_grid.png");
					}
					else{
						var grid = PIXI.Sprite.fromImage("assets/white_grid.png");
					}
				}
				else{
				var grid = PIXI.Sprite.fromImage("assets/grass_grid.png");
				}
			grid.x = gridsize * i;
			grid.y = gridsize * j;
			container.addChild(grid);
			}
		}
		*/
		// button layer over the chessboard
		var buttons = [];
		var noop = function (){
			console.log('click');
		};

		// create a 10 x 12 grid of interactive squares
		for (var i = 0; i < 10; i++){
			for (var j = 0; j < 12; j++){		
				//var button = new PIXI.Sprite(textureButton);
				

				if ((i >= 1 && i <= 8) && (j >= 2 && j <= 9)){
					if ((i%2 == 0 && j%2 != 0) || i%2 != 0 && j%2 ==0){
						var button = PIXI.Sprite.fromImage("assets/black_grid.png");
					}
					else{
						var button = PIXI.Sprite.fromImage("assets/white_grid.png");
						
					}
					// initialize board state
					button.status = 0;
				}
				else{
					var button = PIXI.Sprite.fromImage("assets/grass_grid.png");
					button.status = -1;
				}
					
				//button.status = 99; // declare invalid square
				button.gridNum = (j+i*12);
				button.buttonMode = true;

				button.anchor.set(0.5);

				button.position.x = gridsize*i + gridsize/2;
				button.position.y = gridsize*j + gridsize/2;

				// make the button interactive...
				button.interactive = true;	
				//button transparency
				button.alpha = 0.9;
				//mouse pointer over a button
				button.mouseover = function(){
					this.tint=0x00ff00;
				}
				//mouse pointer leaves a button
				button.mouseout = function(){
					this.tint=defaultColor;
				}

				//detect mouseclick
				button.on('mousedown', movePiece);
				//add touchscreen support
				button.on('touchstart', movePiece);

				button.tap = noop;
				button.click = noop;
				// add it to the stage
				stage.addChild(button);

				// add button to array
				buttons.push(button);
			}
		}

		//Create chess pieces
		// load pawn image
		var pawnTexture = PIXI.Texture.fromImage("assets/wpawn1.png");
		var rookTexture = PIXI.Texture.fromImage("assets/wrook1.png");
		var knightTexture = PIXI.Texture.fromImage("assets/knight-test.png");
		var bishopTexture = PIXI.Texture.fromImage("assets/bishop-test.png");
		var queenTexture = PIXI.Texture.fromImage("assets/queen-test.png");
		var kingTexture = PIXI.Texture.fromImage("assets/king-test.png");
		
		//set pieces array
		var pieces = [];

		//for (var i = 0; i < 16; i++){
		for (var i = 0; i < 20; i++){
			if (i >= 0 && i < 16){
				var piece = new PIXI.Sprite(pawnTexture);
			}
			if (i >= 16 && i < 20){
				var piece = new PIXI.Sprite(rookTexture);
			}
			
			piece.anchor.x = 0.5;
			piece.anchor.y = 0.5;
		
			stage.addChild(piece);
			pieces.push(piece);
			
			if (i < 8){
				pieces[i].tint = 0xffffff;
				pieces[i].pieceColor = white;
				pieces[i].type = 'pawn';
			}
			if (i > 7 && i < 16){
				pieces[i].tint = 0x000000;
				pieces[i].pieceColor = black;
				pieces[i].type = 'pawn';
			}
			if (i == 16 || i == 17){
				pieces[i].tint = 0xffffff;
				pieces[i].pieceColor = white;
				pieces[i].type = 'rook';
			}
			if (i == 18 || i == 19){
				pieces[i].tint = 0x000000;
				pieces[i].pieceColor = black;
				pieces[i].type = 'rook';
			}
			pieces[i].firstMove = true;
		}
		
		//initialize board states		
		//for (var i = 0; i < 120; i++){
		//	buttons[i].status = 0;
		//}
		//Set pawn starting positions
		//White pieces
		for (var i = 0; i < 8; i++){
			buttons[20+(i*12)].status = (i+1);
		}
		//black pieces
		for (var i = 0; i < 8; i++){
			buttons[15+(i*12)].status = (8+i+1);
		}
		//white rooks
		buttons[21].status = 17;
		buttons[105].status = 18;
		//black rooks
		buttons[14].status = 19;
		buttons[98].status = 20;
		
		//declare rows and columns
		//Rows
		
		//Columns
		for (var i = 0; i < 120; i++){
			if (buttons[i].gridNum >=14 && buttons[i].gridNum <= 21){
				buttons[i].colNum = 1;
			}
			if (buttons[i].gridNum >= 26 && buttons[i].gridNum <= 33){
				buttons[i].colNum = 2;
			}
			if (buttons[i].gridNum >=38 && buttons[i].gridNum <= 45){
				buttons[i].colNum = 3;
			}
			if (buttons[i].gridNum >=50 && buttons[i].gridNum <= 57){
				buttons[i].colNum = 4;
			}
			if (buttons[i].gridNum >=62 && buttons[i].gridNum <= 69){
				buttons[i].colNum = 5;
			}
			if (buttons[i].gridNum >=74 && buttons[i].gridNum <= 81){
				buttons[i].colNum = 6;
			}
			if (buttons[i].gridNum >=86 && buttons[i].gridNum <= 93){
				buttons[i].colNum = 7;
			}
			if (buttons[i].gridNum >=98 && buttons[i].gridNum <= 105){
				buttons[i].colNum = 8;
			}
			
		}
		

		/*
		var knightTexture = PIXI.Texture.fromImage("assets/knight-test.png");
		var knights = [];
		for (var i = 0; i < 2; i++){
			var knight = new PIXI.Sprite(knightTexture);
			
			knight.anchor.x = 0.5;
			knight.anchor.y = 0.5;
			
			knight.position.x = buttons[33+(i*5*12)].position.x;
			knight.position.y = buttons[33+(i*12)].position.y;
			
			stage.addChild(knight);
			knights.push(knight);
			knights[i].tint = 0x000000;
		}
		
		var bishopTexture = PIXI.Texture.fromImage("assets/bishop-test.png");
		var bishops = [];
		for (var i = 0; i < 2; i++){
			var bishop = new PIXI.Sprite(bishopTexture);
			
			bishop.anchor.x = 0.5;
			bishop.anchor.y = 0.5;
			
			bishop.position.x = buttons[45+(i*3*12)].position.x;
			bishop.position.y = buttons[45+(i*12)].position.y;
			
			stage.addChild(bishop);
			bishops.push(bishop);
			bishops[i].tint = 0x000000;
		}
		
		var queenTexture = PIXI.Texture.fromImage("assets/queen-test.png");
		var queens = [];
		for (var i = 0; i < 1; i++){
			var queen = new PIXI.Sprite(queenTexture);
			
			queen.anchor.x = 0.5;
			queen.anchor.y = 0.5;
			
			queen.position.x = buttons[57].position.x;
			queen.position.y = buttons[57].position.y;
			
			stage.addChild(queen);
			queens.push(queen);
			queens[i].tint = 0x000000;
		}
		
		var kingTexture = PIXI.Texture.fromImage("assets/king-test.png");
		var kings = [];
		for (var i = 0; i < 1; i++){
			var king = new PIXI.Sprite(kingTexture);
			
			king.anchor.x = 0.5;
			king.anchor.y = 0.5;
			
			king.position.x = buttons[69].position.x;
			king.position.y = buttons[69].position.y;
			
			stage.addChild(king);
			kings.push(king);
			kings[i].tint = 0x000000;
		}
*/
		
		//render the scene
		animate();
		
		//functions
		//render function
		function animate(){
			requestAnimationFrame(animate);
			renderer.render(stage);
			for (var i = 0; i<120; i++){
				//buttons[i].rotation += 0.01;
				
				if (buttons[i].status == 0){
					buttons.tint = defaultColor;
				}
				for (var j = 0; j < 20; j++)
				if (buttons[i].status == j+1) {
					pieces[j].position.x = buttons[i].position.x;
					pieces[j].position.y = buttons[i].position.y;
					pieces[j].gridNum = buttons[i].gridnum;
					pieces[j].colNum = buttons[i].colNum;
				}
			}
		}
		
		function movePiece()
		{
			//if no piece is selected...
			if (currentPiece == 0){
				pieceMoved = false;
				currentPiece = this.status;
				log(this.status);
				this.tint=0xf000f0;
				
				if (this.status > 0 && this.status < numPieces+1){
					pieceType = pieces;
					pieceType[currentPiece-1].tint = 0x00f0f0;
				}

				log('Piece Selected:');
				log(currentPiece);
				currentPosition = this.gridNum;
				log('grid selected');
				log(currentPosition);
				if (currentPiece < 0){
					currentPiece = 0;
				}
				
				if (currentPiece > 0){
					log('currentPiece type:');
					//log(pieceType[currentPiece-1].gridNum);
					log(pieceType[currentPiece-1].type);
					return;
				}
			}
			
			//if there is a piece selected...
			
			//movement rules
			//If player has a piece chosen
			if (currentPiece > 0){
			
				log('current piece original location:');
				log(currentPosition);
				log('new grid');
				log(this.gridNum);

				//PAWNS
				//white pawn movement rules
				if (pieceType[currentPiece-1].type == 'pawn'){
					if (pieceType[currentPiece-1].pieceColor == white){
						//move forward one square
						if (this.gridNum == currentPosition -1 && this.status == 0){
																  
							log('conditions met!');					
							log('Piece Moved');
					
							//update new location
							this.status = currentPiece;
							//update previous location
							buttons[currentPosition].status = 0;
							pieceType[currentPiece-1].firstMove = false;
						}
						//move forward rwo squares IF first move only
						if (pieceType[currentPiece-1].firstMove == true){
							if (this.gridNum == currentPosition -2 && this.status == 0){
								//update new location
								this.status = currentPiece;
								//update previous location
								buttons[currentPosition].status = 0;
								pieceType[currentPiece-1].firstMove = false;
							}
						}
						//capture diagonal left
						//if (this.status > 0 && (this.gridNum == (currentPosition) - (12+1))){
						if (this.status > 0 && ((currentPosition) - (12+1)) == this.gridNum){
							this.status = currentPiece;
							buttons[currentPosition].status = 0;
							pieceType[currentPiece-1].firstMove = false;
						}
						//capture diagonal right
						//if (this.status > 0 && (this.gridnum == (currentPosition) + (12-1))){
						if (this.status > 0 && ((currentPosition) + (12-1)) == this.gridNum){
							this.status = currentPiece;
							buttons[currentPosition].status = 0;
							pieceType[currentPiece-1].firstMove = false;
						}
					}
					//black pawn movement rules
					if (pieceType[currentPiece-1].pieceColor == black){
						if (this.gridNum == currentPosition +1 && this.status == 0){
																  
							log('conditions met!');					
							log('Piece Moved');
					
							//update new location
							this.status = currentPiece;
							//update previous location
							buttons[currentPosition].status = 0;
							pieceType[currentPiece-1].firstMove = false;
						}
						//move forward rwo squares IF first move only
						if (pieceType[currentPiece-1].firstMove == true){
							if (this.gridNum == currentPosition +2 && this.status == 0){
								//update new location
								this.status = currentPiece;
								//update previous location
								buttons[currentPosition].status = 0;
								pieceType[currentPiece-1].firstMove = false;
							}
						}
						if (this.status > 0 && ((currentPosition) - (12-1)) == this.gridNum){
							this.status = currentPiece;
							buttons[currentPosition].status = 0;
							pieceType[currentPiece-1].firstMove = false;
						}
						if (this.status > 0 && ((currentPosition) + (12+1)) == this.gridNum){
							this.status = currentPiece;
							buttons[currentPosition].status = 0;
							pieceType[currentPiece-1].firstMove = false;
						}
					}
				}
				
				//ROOKS
				if (pieceType[currentPiece-1].type == 'rook'){
					if (this.status == 0){
						/*
						if (this.colNum == pieceType[currentPiece-1].colNum){
							this.status = currentPiece;
							buttons[currentPosition].status = 0;
							pieceType[currentPiece-1].firstMove = false;
						}
						*/
						for (var i = 0; i < 8; i++){
							if (this.gridNum > currentPosition && this.status != -1){
								if ((buttons[currentPosition+i].status) == 0){
									this.status = currentPiece;
									buttons[currentPosition].status = 0;
									pieceType[currentPiece-1].firstMove = false;
								}
							}
						}	
					}
				}
				
				//After finishing the move, player no longer has a piece selected
				if (pieceType[currentPiece-1].pieceColor == white){
					pieceType[currentPiece-1].tint = defaultColor;
				}
				if (pieceType[currentPiece-1].pieceColor == black){
					pieceType[currentPiece-1].tint = 0x000000;
				}
				
				currentPiece = 0;
				
				//alternante player turns
				if (playerTurn == 0){playerTurn = 1;}
				if (playerTurn == 1){playerTurn = 0;}
			}
		}
		
		//print error messages for debugging
		function log(msg) {
			setTimeout(function() {
				throw new Error(msg);
			}, 0);
		}
		
		</script>
	</body>
</html>